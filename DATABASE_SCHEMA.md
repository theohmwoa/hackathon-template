# WebFlow Pro - Database Schema Documentation

**Generated by**: Database Agent
**Date**: 2025-11-10
**Purpose**: Complete schema for WebFlow Pro, an AI-powered web development platform

---

## Overview

WebFlow Pro is an AI-powered web development platform that enables users to create, edit, and deploy web applications through an intelligent chat interface. This database schema supports multi-tenant SaaS architecture with complete user isolation through Row Level Security (RLS).

**Total Tables**: 4 (projects, chat_messages, project_files, deployments)
**Authentication**: Supabase Auth (auth.users)
**Security**: Row Level Security (RLS) enabled on all tables
**Total Indexes**: 19 (optimized for common query patterns)

---

## Database Architecture

### Authentication Model
- Uses Supabase GoTrue authentication system
- Users authenticate via `auth.users` table
- All user context available via `auth.uid()` function
- JWT tokens automatically validated by Supabase

### Multi-Tenant Design
- Each project belongs to a single user (user_id)
- All child records (files, messages, deployments) cascade delete when project is deleted
- RLS policies enforce strict user isolation
- No cross-tenant data leakage possible

### Key Design Decisions
1. **Framework as TEXT with CHECK constraint** - More flexible than ENUM for future framework additions
2. **Cascade Deletes** - Ensures data consistency when projects are deleted
3. **Timestamps on all records** - Enables audit trails and sorting by recency
4. **No soft deletes** - WebFlow Pro doesn't require audit trails for these entities
5. **Chat Messages are immutable** - No UPDATE/DELETE triggers; only SELECT/INSERT allowed
6. **Deployment tracking** - Complete history of all deployment attempts maintained

---

## Tables

### 1. projects

**Description**: Stores user projects for the WebFlow Pro platform. Each project represents a web application that can be edited, tested, and deployed.

**File**: `/database/init/02-projects.sql`

**Schema**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique project identifier |
| user_id | UUID | FK → auth.users(id), NOT NULL, ON DELETE CASCADE | Project owner |
| name | TEXT | NOT NULL | Project name (required, user-facing) |
| description | TEXT | NULLABLE | Long-form project description |
| framework | TEXT | CHECK (framework IN ('react', 'vue', 'angular')), DEFAULT 'react' | Frontend framework selection |
| template | TEXT | DEFAULT 'blank' | Template used to initialize project (e.g., blank, nextjs, vite, etc.) |
| thumbnail_url | TEXT | NULLABLE | Project screenshot/thumbnail URL (from Supabase Storage) |
| is_deployed | BOOLEAN | DEFAULT false | Deployment status flag |
| deployment_url | TEXT | NULLABLE | Live URL of deployed application |
| last_opened_at | TIMESTAMP WITH TIME ZONE | NULLABLE | Timestamp of last project access (for recency sorting) |
| created_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | Project creation timestamp |
| updated_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | Last project modification timestamp |

**Indexes**:
- `projects_user_id_idx` - user_id (FK optimization, essential for filtering by owner)
- `projects_created_at_idx` - created_at DESC (for sorting all projects by creation)
- `projects_last_opened_idx` - last_opened_at DESC NULLS LAST (for recent projects sorting)
- `projects_framework_idx` - framework (for filtering by framework)
- `projects_is_deployed_idx` - is_deployed (for filtering deployed vs non-deployed)
- `projects_user_created_idx` - (user_id, created_at DESC) (composite for user projects sorted by creation)
- `projects_user_recent_idx` - (user_id, last_opened_at DESC NULLS LAST) (composite for user's recent projects)

**RLS Policies**:
1. **SELECT**: Users can view only their own projects
2. **INSERT**: Authenticated users can create projects (user_id must match auth.uid())
3. **UPDATE**: Users can update only their own projects
4. **DELETE**: Users can delete only their own projects

**Relationships**:
- Owned by: `auth.users` (via user_id)
- Has many: `chat_messages` (project_id, cascade delete)
- Has many: `project_files` (project_id, cascade delete)
- Has many: `deployments` (project_id, cascade delete)

**Triggers**:
- `update_projects_updated_at` - Auto-updates updated_at on any UPDATE

---

### 2. chat_messages

**Description**: Stores conversation history between users and the AI assistant within a project context. Messages are immutable and provide a complete audit trail of project development decisions.

**File**: `/database/init/03-messages.sql`

**Schema**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique message identifier |
| project_id | UUID | FK → projects(id), NOT NULL, ON DELETE CASCADE | Project this message belongs to |
| role | TEXT | CHECK (role IN ('user', 'assistant')), NOT NULL | Message sender: 'user' (human) or 'assistant' (AI) |
| content | TEXT | NOT NULL | Complete message text/content |
| created_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | Message creation timestamp (immutable) |

**Indexes**:
- `chat_messages_project_id_idx` - project_id (FK optimization, essential for retrieving conversation)
- `chat_messages_created_at_idx` - created_at ASC (for chronological conversation order)
- `chat_messages_project_created_idx` - (project_id, created_at ASC) (composite for retrieving full conversation in order)
- `chat_messages_role_idx` - role (for filtering user vs assistant messages)

**RLS Policies**:
1. **SELECT**: Users can view messages only for their own projects
2. **INSERT**: Users can create messages only for their own projects
3. **UPDATE**: Users can update messages only for their own projects
4. **DELETE**: Users can delete messages only for their own projects

**Note on Immutability**: While UPDATE/DELETE policies exist for flexibility, typical application flow only allows INSERT and SELECT operations. Consider the chat_messages as an append-only log.

**Relationships**:
- Belongs to: `projects` (via project_id, cascade delete)
- Project ownership verified through projects table RLS

**Design Notes**:
- No user_id stored (determined through project ownership)
- No updated_at (messages are created once, order determined by created_at)
- Chronological ASC index for efficient conversation retrieval
- Perfect for real-time subscriptions via Supabase Realtime

### 3. project_files

**Description**: Stores the complete codebase for each project, with support for multiple file types (TypeScript/React, CSS, HTML, JSON configuration files). Each file path is unique within a project.

**File**: `/database/init/04-project-files.sql`

**Schema**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique file identifier |
| project_id | UUID | FK → projects(id), NOT NULL, ON DELETE CASCADE | Project this file belongs to |
| file_path | TEXT | NOT NULL | File path within project (e.g., 'src/App.tsx', 'styles/main.css') |
| file_content | TEXT | NOT NULL | Complete file content/source code |
| file_type | TEXT | CHECK (file_type IN ('tsx', 'css', 'html', 'json')), NOT NULL | File type for syntax highlighting/validation |
| created_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | File creation timestamp |
| updated_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | File last modification timestamp |
| UNIQUE(project_id, file_path) | - | - | Ensures one file per path per project |

**Indexes**:
- `project_files_project_id_idx` - project_id (FK optimization)
- `project_files_path_idx` - file_path (for quick file lookups by path)
- `project_files_type_idx` - file_type (for filtering files by type)
- `project_files_created_at_idx` - created_at DESC (for sorting files by creation)
- `project_files_project_created_idx` - (project_id, created_at DESC) (composite for retrieving all project files sorted)

**RLS Policies**:
1. **SELECT**: Users can view files only for their own projects
2. **INSERT**: Users can create files only for their own projects
3. **UPDATE**: Users can update files only for their own projects
4. **DELETE**: Users can delete files only for their own projects

**Relationships**:
- Belongs to: `projects` (via project_id, cascade delete)
- Project ownership verified through projects table RLS

**Constraints**:
- File path must be unique within project (prevents duplicates)
- File type restricted to supported types
- Content stored as TEXT (PostgreSQL handles large text efficiently)

**Triggers**:
- `update_project_files_updated_at` - Auto-updates updated_at on any UPDATE

**Design Notes**:
- File content stored directly in database (suitable for dev/demo; production might use external storage)
- UNIQUE constraint on (project_id, file_path) prevents duplicate files
- file_type used for frontend syntax highlighting, not validation
- Perfect for real-time syncing via Supabase Realtime

---

### 4. deployments

**Description**: Tracks complete deployment history for projects, including status transitions and logs. Enables users to monitor deployment progress and troubleshoot failed builds.

**File**: `/database/init/05-deployments.sql`

**Schema**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique deployment record identifier |
| project_id | UUID | FK → projects(id), NOT NULL, ON DELETE CASCADE | Project being deployed |
| status | TEXT | CHECK (status IN ('pending', 'building', 'deploying', 'success', 'failed')), DEFAULT 'pending' | Deployment lifecycle status |
| deployment_url | TEXT | NULLABLE | Live URL of successfully deployed application |
| build_log | TEXT | NULLABLE | Complete build/deployment logs for debugging |
| created_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | Deployment attempt creation timestamp |
| updated_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | Last status update timestamp |

**Indexes**:
- `deployments_project_id_idx` - project_id (FK optimization, for retrieving project deployments)
- `deployments_status_idx` - status (for filtering by deployment status)
- `deployments_created_at_idx` - created_at DESC (for sorting by deployment time)
- `deployments_project_created_idx` - (project_id, created_at DESC) (composite for retrieving project deployment history)
- `deployments_status_created_idx` - (status, created_at DESC) (composite for finding recent deployments by status)

**RLS Policies**:
1. **SELECT**: Users can view deployments only for their own projects
2. **INSERT**: Users can create deployments only for their own projects
3. **UPDATE**: Users can update deployments only for their own projects
4. **DELETE**: Users can delete deployments only for their own projects

**Relationships**:
- Belongs to: `projects` (via project_id, cascade delete)
- Project ownership verified through projects table RLS

**Status Lifecycle**:
- **pending**: Deployment created, waiting to start
- **building**: Build process in progress
- **deploying**: Build complete, deployment in progress
- **success**: Deployment completed successfully, deployment_url is valid
- **failed**: Deployment failed, check build_log for error details

**Triggers**:
- `update_deployments_updated_at` - Auto-updates updated_at on any UPDATE

**Design Notes**:
- Single deployment_url (overwritten on each successful deployment)
- Build logs stored in database for auditing and debugging
- Status field enables real-time UI updates via Supabase Realtime
- Complete history maintained (no deletions), enabling deployment rollback analysis

---

## Entity Relationship Diagram (ERD)

```
auth.users (Supabase Auth)
    │
    └─→ projects (user_id, 1:N)
            │
            ├─→ chat_messages (project_id, 1:N, cascade delete)
            │   └─ Stores conversation history
            │
            ├─→ project_files (project_id, 1:N, cascade delete)
            │   └─ Stores all project source code
            │
            └─→ deployments (project_id, 1:N, cascade delete)
                └─ Stores deployment attempts and history
```

---

## Backend Agent Instructions

### Modules to Generate

Generate the following NestJS modules in `backend/src/`:

#### 1. **Projects Module** (Full CRUD)
- **Entity**: `Project` (matching database schema)
- **DTOs**:
  - `CreateProjectDto`: name, description, framework, template
  - `UpdateProjectDto`: name, description, template, thumbnail_url, is_deployed, deployment_url, last_opened_at
  - `ProjectResponseDto`: All public fields
- **Service**: `ProjectsService`
  - `create(createProjectDto)`: Create new project
  - `findAll(userId)`: List user's projects
  - `findOne(id)`: Get single project
  - `update(id, updateProjectDto)`: Update project
  - `delete(id)`: Delete project
  - `updateLastOpened(id)`: Update last_opened_at to NOW()
- **Controller**: `ProjectsController`
  - GET `/projects` - List user's projects
  - POST `/projects` - Create project
  - GET `/projects/:id` - Get project details
  - PATCH `/projects/:id` - Update project
  - DELETE `/projects/:id` - Delete project
  - PATCH `/projects/:id/opened` - Update last_opened_at

#### 2. **Chat Messages Module** (Read & Create, No Updates)
- **Entity**: `ChatMessage` (matching database schema)
- **DTOs**:
  - `CreateChatMessageDto`: role, content
  - `ChatMessageResponseDto`: All fields
- **Service**: `ChatMessagesService`
  - `create(projectId, createMessageDto)`: Add message to conversation
  - `findByProject(projectId)`: Get all messages for project
  - `findById(id)`: Get single message
- **Controller**: `ChatMessagesController`
  - GET `/projects/:projectId/messages` - Get conversation
  - POST `/projects/:projectId/messages` - Add message
  - Consider WebSocket endpoint for real-time updates

**Important**: Messages are immutable. Do not expose UPDATE/DELETE endpoints.

#### 3. **Project Files Module** (Full CRUD)
- **Entity**: `ProjectFile` (matching database schema)
- **DTOs**:
  - `CreateProjectFileDto`: file_path, file_content, file_type
  - `UpdateProjectFileDto`: file_content (path and type typically immutable)
  - `ProjectFileResponseDto`: All fields
- **Service**: `ProjectFilesService`
  - `create(projectId, createFileDto)`: Create/save file
  - `findByProject(projectId)`: Get all files in project
  - `findByPath(projectId, filePath)`: Get specific file
  - `update(id, updateFileDto)`: Update file content
  - `delete(id)`: Delete file
- **Controller**: `ProjectFilesController`
  - GET `/projects/:projectId/files` - List project files
  - POST `/projects/:projectId/files` - Create file
  - GET `/projects/:projectId/files/:filePath` - Get file content
  - PATCH `/projects/:projectId/files/:filePath` - Update file content
  - DELETE `/projects/:projectId/files/:filePath` - Delete file

#### 4. **Deployments Module** (Read & Create)
- **Entity**: `Deployment` (matching database schema)
- **DTOs**:
  - `CreateDeploymentDto`: status (default: 'pending')
  - `UpdateDeploymentStatusDto`: status, deployment_url (optional), build_log (optional)
  - `DeploymentResponseDto`: All fields
- **Service**: `DeploymentsService`
  - `create(projectId)`: Initiate new deployment
  - `findByProject(projectId)`: Get deployment history
  - `findById(id)`: Get deployment details
  - `updateStatus(id, updateStatusDto)`: Update deployment status
  - `getLatest(projectId)`: Get most recent deployment
- **Controller**: `DeploymentsController`
  - GET `/projects/:projectId/deployments` - Get deployment history
  - POST `/projects/:projectId/deployments` - Start new deployment
  - GET `/projects/:projectId/deployments/:id` - Get deployment details
  - PATCH `/projects/:projectId/deployments/:id` - Update status/logs

---

### Authentication Requirements

**Protected Routes**:
- All POST, PATCH, DELETE operations require authentication
- GET operations for user-specific data (e.g., drafts) require authentication
- Use `@UseGuards(AuthGuard())` on all controllers

**User Context**:
- Extract user ID from JWT token using AuthGuard
- Pass user ID to service layer for RLS enforcement
- Database RLS policies automatically filter based on auth.uid()

**Database Connection**:

Use Supabase client library:

```typescript
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_KEY, // Use service key for admin operations
);
```

For authenticated requests (respecting RLS):

```typescript
const { data, error } = await supabaseClient
  .from('projects')
  .select('*');
// RLS automatically filters based on JWT token
```

---

### Special Considerations

#### 1. File Content Size
TEXT column supports large files (tested up to 1MB+)

#### 2. Deployment Logs
May grow large; consider external storage for logs > 100KB

#### 3. Message History
Conversations can be long; implement pagination (limit 50, offset)

#### 4. Concurrent Updates
Last write wins for file content; consider conflict resolution

#### 5. Rate Limiting
Implement rate limits on file updates (max 100/min per project)

---

## Security Model

### Row Level Security (RLS)

All user-facing tables have comprehensive RLS policies:

1. **User Isolation**: `auth.uid()` compared against user_id ensures complete user isolation
2. **Project Ownership**: Child tables verify project ownership through projects table
3. **No Public Data**: No policies allow anonymous/unauthenticated access
4. **Operation Coverage**: SELECT, INSERT, UPDATE, DELETE all restricted

This pattern is applied to all child tables, ensuring no user can access another user's resources.

---

## Performance Considerations

### Index Strategy

1. **Foreign Key Indexes**: Every FK has an index for join optimization
2. **Filter Column Indexes**: Frequently filtered columns (status, framework, role) have indexes
3. **Sort Column Indexes**: Columns used in ORDER BY have DESC indexes where appropriate
4. **Composite Indexes**: Common multi-column queries have composite indexes
5. **NULLS LAST**: Handles nullable columns like last_opened_at and deployment_url

### Query Optimization Tips

1. **User Projects**: Use `projects_user_recent_idx` for dashboard queries
2. **Conversation Retrieval**: Use `chat_messages_project_created_idx` with ASC order
3. **Deployment Status**: Use `deployments_status_created_idx` for status dashboards
4. **File Access**: Use `project_files_project_created_idx` for file tree listings

### Expected Performance

- **Single user's projects**: O(log n) via index
- **Full conversation**: O(log n) fetch + O(m) streaming where m = message count
- **File tree**: O(log n) fetch + O(m) streaming where m = file count
- **Deployment history**: O(log n) fetch + O(m) streaming where m = deployment count

---

## Database Setup & Migration

### Initial Setup

```bash
# Database migrations auto-apply from database/init/
# Files execute in alphabetical order:
1. 01-init.sql (Supabase placeholders)
2. 01-auth-schema.sql (Auth schema setup)
3. 02-projects.sql (Projects table)
4. 03-messages.sql (Chat messages table)
5. 04-project-files.sql (Project files table)
6. 05-deployments.sql (Deployments table)
```

### Environment Setup

```env
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_SERVICE_KEY=your-service-key
SUPABASE_PUBLIC_KEY=your-public-key
```

### Verification Queries

After setup, verify the schema:

```sql
-- Check tables exist
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public';

-- Check RLS is enabled
SELECT tablename, rowsecurity
FROM pg_tables
WHERE schemaname = 'public';

-- Check policies exist
SELECT tablename, policyname, cmd
FROM pg_policies
WHERE schemaname = 'public';

-- Check indexes
SELECT tablename, indexname
FROM pg_indexes
WHERE schemaname = 'public';
```

---

## Security Notes

### Row Level Security (RLS)

**All tables have RLS enabled** with the following security model:

1. **User Isolation**: Users can only access their own projects
2. **Project-Based Access**: Messages are accessible only through owned projects
3. **JWT-Based Auth**: All policies use `auth.uid()` from Supabase JWT
4. **Cascading Security**: Deleting a project removes all associated messages

### Security Best Practices

1. **Never disable RLS** - even for admin operations, create specific policies
2. **Validate ownership** - backend should double-check project ownership for message operations
3. **Use parameterized queries** - prevent SQL injection (Supabase client handles this)
4. **Sanitize content** - messages should be sanitized for XSS before display (frontend responsibility)
5. **Rate limiting** - consider rate limits on message creation to prevent spam

### JWT Token Handling

The backend must:
1. Extract JWT token from request headers (`Authorization: Bearer <token>`)
2. Pass token to Supabase client for RLS enforcement
3. Never trust user_id from request body - always use authenticated user from token

---

## Performance Optimization

### Query Patterns

The schema is optimized for these common queries:

1. **List user's projects** (most recent first):
   - Uses: `projects_user_created_idx`
   ```sql
   SELECT * FROM projects
   WHERE user_id = $1
   ORDER BY created_at DESC;
   ```

2. **Get all messages for a project** (chronological):
   - Uses: `messages_project_created_idx`
   ```sql
   SELECT * FROM messages
   WHERE project_id = $1
   ORDER BY created_at ASC;
   ```

3. **Verify project ownership**:
   - Uses: `projects_user_id_idx` (primary key lookup)
   ```sql
   SELECT id FROM projects
   WHERE id = $1 AND user_id = $2;
   ```

### Index Strategy

All foreign keys have indexes to optimize:
- JOIN operations between tables
- CASCADE delete performance
- RLS policy checks

### Potential Bottlenecks

1. **Large message threads**: Consider pagination for projects with >1000 messages
2. **User with many projects**: Default sorting by created_at DESC helps show recent projects first
3. **Complex RLS policies**: Messages table has JOIN in RLS policy - monitor query performance

---

## Testing Data

For development and testing, you can seed sample data:

```sql
-- Insert test user (normally handled by Supabase Auth)
INSERT INTO auth.users (id, email, encrypted_password)
VALUES (gen_random_uuid(), 'test@example.com', 'hashed_password');

-- Insert test project
INSERT INTO public.projects (user_id, name, description)
VALUES (
  (SELECT id FROM auth.users WHERE email = 'test@example.com'),
  'My First Project',
  'A sample project for testing'
);

-- Insert test messages
INSERT INTO public.messages (project_id, user_id, content, role)
VALUES
  (
    (SELECT id FROM public.projects WHERE name = 'My First Project'),
    (SELECT id FROM auth.users WHERE email = 'test@example.com'),
    'Hello, how can I build a chat app?',
    'user'
  ),
  (
    (SELECT id FROM public.projects WHERE name = 'My First Project'),
    (SELECT id FROM auth.users WHERE email = 'test@example.com'),
    'I can help you build a chat application! Let me start by...',
    'assistant'
  );
```

---

## Migration Strategy

### Future Schema Changes

When adding new features, follow this pattern:

1. **Adding columns**: Use `ALTER TABLE ADD COLUMN` with defaults
   ```sql
   ALTER TABLE public.messages
   ADD COLUMN metadata JSONB DEFAULT '{}'::jsonb;
   ```

2. **Adding indexes**: Create concurrently to avoid locks
   ```sql
   CREATE INDEX CONCURRENTLY messages_metadata_idx
   ON public.messages USING gin(metadata);
   ```

3. **Modifying RLS**: Drop and recreate policies
   ```sql
   DROP POLICY "policy_name" ON public.messages;
   CREATE POLICY "new_policy_name" ON public.messages ...;
   ```

### Backward Compatibility

Always ensure:
- New columns are NULLABLE or have DEFAULT values
- Existing indexes remain functional
- RLS policies don't break existing queries

---

## Next Steps

### For Backend Agent

1. **Read this document** carefully to understand the schema
2. **Generate NestJS modules** for projects and messages
3. **Implement authentication** using Supabase JWT guards
4. **Create DTOs** matching the schema specifications above
5. **Add validation** for all input fields
6. **Test RLS policies** to ensure security works correctly
7. **Generate OpenAPI spec** for Frontend Agent to consume

### Testing Checklist

- [ ] Users can create projects
- [ ] Users can only see their own projects
- [ ] Users can create messages in their projects
- [ ] Users cannot create messages in other users' projects
- [ ] Deleting a project deletes all its messages
- [ ] Messages are returned in chronological order
- [ ] Updated_at timestamp auto-updates on changes
- [ ] Role constraint enforces 'user' or 'assistant' only

### Deployment Checklist

- [ ] Database migrations tested in staging environment
- [ ] RLS policies verified with multiple test users
- [ ] Indexes analyzed with EXPLAIN queries
- [ ] Backup strategy configured
- [ ] Monitoring set up for slow queries

---

## Contact & Support

For questions about this schema:
- Review the SQL files in `database/init/`
- Check RLS policies if access issues occur
- Monitor database logs for policy violations
- Use `EXPLAIN ANALYZE` for query performance issues

---

**End of Database Schema Documentation**
