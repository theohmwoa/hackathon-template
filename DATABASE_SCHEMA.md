# Database Schema Documentation

**Generated by**: Database Agent
**Date**: 2025-11-09
**Purpose**: Handoff document for Backend Agent to generate NestJS modules

---

## Overview

This database schema supports a **Lovable-style chat application** where users can create projects and have chat conversations with an AI assistant within those projects.

**Total Tables**: 2 (projects, messages)
**Authentication**: Supabase Auth (auth.users)
**Security**: Row Level Security (RLS) enabled on all tables

---

## Architecture

### Data Model

The application follows a hierarchical structure:
- **Users** (managed by Supabase Auth)
  - Own multiple **Projects**
    - Each project contains multiple **Messages** (conversation history)

### Key Features

1. **Project Isolation**: Each user's projects are completely isolated from other users
2. **Cascading Deletes**: When a project is deleted, all associated messages are automatically removed
3. **Role-Based Messages**: Messages are tagged as either "user" or "assistant" to distinguish conversation participants
4. **Audit Trail**: All tables include created_at and updated_at timestamps

---

## Tables

### 1. projects

**Description**: Stores user projects that contain chat conversations

**File**: `database/init/02-projects.sql`

**Schema**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique identifier |
| user_id | UUID | FK → auth.users(id), NOT NULL, ON DELETE CASCADE | Owner of the project |
| name | TEXT | NOT NULL | Project name |
| description | TEXT | NULLABLE | Optional project description |
| created_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | Last update timestamp |

**Indexes**:
- `projects_user_id_idx` on user_id
- `projects_created_at_idx` on created_at DESC
- `projects_user_created_idx` on (user_id, created_at DESC)

**RLS Policies**:
1. **SELECT**: Users can view only their own projects (WHERE user_id = auth.uid())
2. **INSERT**: Authenticated users can create projects for themselves
3. **UPDATE**: Users can update only their own projects
4. **DELETE**: Users can delete only their own projects

**Relationships**:
- Belongs to `auth.users` (via user_id)
- Has many `messages` (via project_id)

**Triggers**:
- Auto-updates `updated_at` on every UPDATE operation

---

### 2. messages

**Description**: Stores chat messages between users and AI assistant within projects

**File**: `database/init/03-messages.sql`

**Schema**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique identifier |
| project_id | UUID | FK → projects(id), NOT NULL, ON DELETE CASCADE | Project this message belongs to |
| user_id | UUID | FK → auth.users(id), NOT NULL, ON DELETE CASCADE | Owner of the message thread |
| content | TEXT | NOT NULL | Message content/text |
| role | TEXT | NOT NULL, CHECK (role IN ('user', 'assistant')) | Message sender role |
| created_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | Last update timestamp |

**Indexes**:
- `messages_project_id_idx` on project_id
- `messages_user_id_idx` on user_id
- `messages_created_at_idx` on created_at DESC
- `messages_project_created_idx` on (project_id, created_at ASC) - **Primary query pattern**
- `messages_user_created_idx` on (user_id, created_at DESC)
- `messages_role_idx` on role

**RLS Policies**:
1. **SELECT**: Users can view messages for projects they own (verified via JOIN with projects table)
2. **INSERT**: Users can create messages only for their own projects
3. **UPDATE**: Users can update messages only for their own projects
4. **DELETE**: Users can delete messages only for their own projects

**Relationships**:
- Belongs to `projects` (via project_id) - **cascading delete**
- Belongs to `auth.users` (via user_id)

**Triggers**:
- Auto-updates `updated_at` on every UPDATE operation

**Business Rules**:
- Messages must have a role of either 'user' or 'assistant' (enforced via CHECK constraint)
- Messages are ordered chronologically within each project (created_at ASC)
- Deleting a project automatically deletes all its messages (ON DELETE CASCADE)

---

## Entity Relationship Diagram (ERD)

```
auth.users (Supabase Auth)
    |
    └─→ projects (user_id)
          |
          └─→ messages (project_id, user_id)
```

**Relationship Details**:
- One user has many projects (1:N)
- One project has many messages (1:N)
- One user has many messages (1:N)
- Messages belong to both a project and a user

---

## Backend Agent Instructions

### Modules to Generate

Generate the following NestJS modules in `backend/src/`:

#### 1. **projects** Module
Full CRUD operations for project management

**DTOs**:
- `CreateProjectDto`:
  ```typescript
  {
    name: string;          // required
    description?: string;  // optional
  }
  ```
- `UpdateProjectDto`: Partial version of CreateProjectDto
- `ProjectResponseDto`: Complete project object with id, timestamps

**Entity**: `Project`
```typescript
{
  id: string;              // UUID
  user_id: string;         // UUID (from auth context)
  name: string;
  description: string | null;
  created_at: Date;
  updated_at: Date;
}
```

**Service Methods**:
- `create(userId: string, dto: CreateProjectDto): Promise<Project>`
- `findAll(userId: string): Promise<Project[]>` - Get all user's projects
- `findOne(projectId: string, userId: string): Promise<Project>` - Get single project with ownership check
- `update(projectId: string, userId: string, dto: UpdateProjectDto): Promise<Project>`
- `remove(projectId: string, userId: string): Promise<void>`

**Controller Endpoints**:
- `POST /projects` - Create new project (authenticated)
- `GET /projects` - List all user's projects (authenticated)
- `GET /projects/:id` - Get single project (authenticated)
- `PATCH /projects/:id` - Update project (authenticated)
- `DELETE /projects/:id` - Delete project (authenticated)

---

#### 2. **messages** Module
Full CRUD operations for chat messages within projects

**DTOs**:
- `CreateMessageDto`:
  ```typescript
  {
    project_id: string;    // UUID, required
    content: string;       // required
    role: 'user' | 'assistant';  // required
  }
  ```
- `UpdateMessageDto`:
  ```typescript
  {
    content?: string;
  }
  ```
- `MessageResponseDto`: Complete message object with id, timestamps

**Entity**: `Message`
```typescript
{
  id: string;              // UUID
  project_id: string;      // UUID
  user_id: string;         // UUID (from auth context)
  content: string;
  role: 'user' | 'assistant';
  created_at: Date;
  updated_at: Date;
}
```

**Service Methods**:
- `create(userId: string, dto: CreateMessageDto): Promise<Message>` - Verify project ownership before creating
- `findAllByProject(projectId: string, userId: string): Promise<Message[]>` - Get all messages for a project (chronological order)
- `findOne(messageId: string, userId: string): Promise<Message>` - Get single message with ownership check
- `update(messageId: string, userId: string, dto: UpdateMessageDto): Promise<Message>`
- `remove(messageId: string, userId: string): Promise<void>`

**Controller Endpoints**:
- `POST /messages` - Create new message (authenticated)
- `GET /projects/:projectId/messages` - List all messages for a project (authenticated)
- `GET /messages/:id` - Get single message (authenticated)
- `PATCH /messages/:id` - Update message (authenticated)
- `DELETE /messages/:id` - Delete message (authenticated)

---

### Authentication Requirements

**Protected Routes**:
- **ALL endpoints require authentication** - use `@UseGuards(AuthGuard)` on all controllers
- Extract user ID from JWT token using `@CurrentUser()` decorator or similar pattern

**User Context**:
- Extract `user_id` from authenticated JWT token (Supabase sets this in the token)
- Pass user ID to all service layer methods for RLS enforcement
- **Never** trust user_id from request body - always use the authenticated user's ID from the token

**RLS Enforcement**:
- Database RLS policies automatically filter results based on auth.uid()
- Backend must set the correct JWT token in Supabase client for each request
- Service layer should pass user context to ensure proper scoping

**Example Authentication Flow**:
```typescript
// In controller
@UseGuards(AuthGuard)
@Post('projects')
async create(
  @CurrentUser() user: User,
  @Body() dto: CreateProjectDto
) {
  return this.projectsService.create(user.id, dto);
}

// In service
async create(userId: string, dto: CreateProjectDto) {
  // Supabase client automatically enforces RLS using the user's JWT
  const { data, error } = await this.supabase
    .from('projects')
    .insert({
      user_id: userId,  // Explicitly set to authenticated user
      ...dto
    })
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data;
}
```

---

### Special Considerations

#### 1. Project Ownership Validation
When creating or accessing messages, **always verify the user owns the project**:
```typescript
// Before creating a message
const project = await this.projectsService.findOne(dto.project_id, userId);
if (!project) {
  throw new ForbiddenException('Project not found or access denied');
}
```

#### 2. Message Ordering
Messages should be returned in chronological order (oldest first) for chat display:
```typescript
// In Supabase query
.order('created_at', { ascending: true })
```

#### 3. Cascading Deletes
When a project is deleted, messages are automatically deleted via database CASCADE. No additional backend logic needed.

#### 4. Real-Time Subscriptions (Optional Enhancement)
Consider implementing Supabase real-time subscriptions for live chat updates:
```typescript
// Subscribe to new messages in a project
supabase
  .channel(`project:${projectId}`)
  .on('postgres_changes',
    { event: 'INSERT', schema: 'public', table: 'messages', filter: `project_id=eq.${projectId}` },
    (payload) => {
      // Handle new message
    }
  )
  .subscribe();
```

#### 5. Message Role Validation
Enforce the role enum ('user' | 'assistant') in DTOs:
```typescript
@IsEnum(['user', 'assistant'])
role: 'user' | 'assistant';
```

#### 6. Pagination
For projects with many messages, implement pagination:
```typescript
// Add query parameters
@Query('limit') limit: number = 50,
@Query('offset') offset: number = 0,

// In Supabase query
.range(offset, offset + limit - 1)
```

#### 7. Error Handling
Handle common Supabase errors:
- `23503`: Foreign key violation (invalid project_id)
- `23505`: Unique constraint violation
- `42501`: RLS policy violation (insufficient permissions)

---

## Database Setup

To apply this schema:

```bash
# Start database
docker compose up -d postgres

# Migrations will auto-apply from database/init/
# Files execute in alphabetical order:
#   1. 01-init.sql (base setup)
#   2. 01-auth-schema.sql (auth schema + functions)
#   3. 02-projects.sql (projects table)
#   4. 03-messages.sql (messages table)
```

### Verification Queries

After setup, verify the schema:

```sql
-- Check tables exist
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public';

-- Check RLS is enabled
SELECT tablename, rowsecurity
FROM pg_tables
WHERE schemaname = 'public';

-- Check policies exist
SELECT tablename, policyname, cmd
FROM pg_policies
WHERE schemaname = 'public';

-- Check indexes
SELECT tablename, indexname
FROM pg_indexes
WHERE schemaname = 'public';
```

---

## Security Notes

### Row Level Security (RLS)

**All tables have RLS enabled** with the following security model:

1. **User Isolation**: Users can only access their own projects
2. **Project-Based Access**: Messages are accessible only through owned projects
3. **JWT-Based Auth**: All policies use `auth.uid()` from Supabase JWT
4. **Cascading Security**: Deleting a project removes all associated messages

### Security Best Practices

1. **Never disable RLS** - even for admin operations, create specific policies
2. **Validate ownership** - backend should double-check project ownership for message operations
3. **Use parameterized queries** - prevent SQL injection (Supabase client handles this)
4. **Sanitize content** - messages should be sanitized for XSS before display (frontend responsibility)
5. **Rate limiting** - consider rate limits on message creation to prevent spam

### JWT Token Handling

The backend must:
1. Extract JWT token from request headers (`Authorization: Bearer <token>`)
2. Pass token to Supabase client for RLS enforcement
3. Never trust user_id from request body - always use authenticated user from token

---

## Performance Optimization

### Query Patterns

The schema is optimized for these common queries:

1. **List user's projects** (most recent first):
   - Uses: `projects_user_created_idx`
   ```sql
   SELECT * FROM projects
   WHERE user_id = $1
   ORDER BY created_at DESC;
   ```

2. **Get all messages for a project** (chronological):
   - Uses: `messages_project_created_idx`
   ```sql
   SELECT * FROM messages
   WHERE project_id = $1
   ORDER BY created_at ASC;
   ```

3. **Verify project ownership**:
   - Uses: `projects_user_id_idx` (primary key lookup)
   ```sql
   SELECT id FROM projects
   WHERE id = $1 AND user_id = $2;
   ```

### Index Strategy

All foreign keys have indexes to optimize:
- JOIN operations between tables
- CASCADE delete performance
- RLS policy checks

### Potential Bottlenecks

1. **Large message threads**: Consider pagination for projects with >1000 messages
2. **User with many projects**: Default sorting by created_at DESC helps show recent projects first
3. **Complex RLS policies**: Messages table has JOIN in RLS policy - monitor query performance

---

## Testing Data

For development and testing, you can seed sample data:

```sql
-- Insert test user (normally handled by Supabase Auth)
INSERT INTO auth.users (id, email, encrypted_password)
VALUES (gen_random_uuid(), 'test@example.com', 'hashed_password');

-- Insert test project
INSERT INTO public.projects (user_id, name, description)
VALUES (
  (SELECT id FROM auth.users WHERE email = 'test@example.com'),
  'My First Project',
  'A sample project for testing'
);

-- Insert test messages
INSERT INTO public.messages (project_id, user_id, content, role)
VALUES
  (
    (SELECT id FROM public.projects WHERE name = 'My First Project'),
    (SELECT id FROM auth.users WHERE email = 'test@example.com'),
    'Hello, how can I build a chat app?',
    'user'
  ),
  (
    (SELECT id FROM public.projects WHERE name = 'My First Project'),
    (SELECT id FROM auth.users WHERE email = 'test@example.com'),
    'I can help you build a chat application! Let me start by...',
    'assistant'
  );
```

---

## Migration Strategy

### Future Schema Changes

When adding new features, follow this pattern:

1. **Adding columns**: Use `ALTER TABLE ADD COLUMN` with defaults
   ```sql
   ALTER TABLE public.messages
   ADD COLUMN metadata JSONB DEFAULT '{}'::jsonb;
   ```

2. **Adding indexes**: Create concurrently to avoid locks
   ```sql
   CREATE INDEX CONCURRENTLY messages_metadata_idx
   ON public.messages USING gin(metadata);
   ```

3. **Modifying RLS**: Drop and recreate policies
   ```sql
   DROP POLICY "policy_name" ON public.messages;
   CREATE POLICY "new_policy_name" ON public.messages ...;
   ```

### Backward Compatibility

Always ensure:
- New columns are NULLABLE or have DEFAULT values
- Existing indexes remain functional
- RLS policies don't break existing queries

---

## Next Steps

### For Backend Agent

1. **Read this document** carefully to understand the schema
2. **Generate NestJS modules** for projects and messages
3. **Implement authentication** using Supabase JWT guards
4. **Create DTOs** matching the schema specifications above
5. **Add validation** for all input fields
6. **Test RLS policies** to ensure security works correctly
7. **Generate OpenAPI spec** for Frontend Agent to consume

### Testing Checklist

- [ ] Users can create projects
- [ ] Users can only see their own projects
- [ ] Users can create messages in their projects
- [ ] Users cannot create messages in other users' projects
- [ ] Deleting a project deletes all its messages
- [ ] Messages are returned in chronological order
- [ ] Updated_at timestamp auto-updates on changes
- [ ] Role constraint enforces 'user' or 'assistant' only

### Deployment Checklist

- [ ] Database migrations tested in staging environment
- [ ] RLS policies verified with multiple test users
- [ ] Indexes analyzed with EXPLAIN queries
- [ ] Backup strategy configured
- [ ] Monitoring set up for slow queries

---

## Contact & Support

For questions about this schema:
- Review the SQL files in `database/init/`
- Check RLS policies if access issues occur
- Monitor database logs for policy violations
- Use `EXPLAIN ANALYZE` for query performance issues

---

**End of Database Schema Documentation**
